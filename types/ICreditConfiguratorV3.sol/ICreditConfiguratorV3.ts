/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export interface ICreditConfiguratorV3Interface extends utils.Interface {
  functions: {
    "addCollateralToken(address,uint16)": FunctionFragment;
    "addEmergencyLiquidator(address)": FunctionFragment;
    "addressProvider()": FunctionFragment;
    "allowAdapter(address)": FunctionFragment;
    "allowToken(address)": FunctionFragment;
    "allowedAdapters()": FunctionFragment;
    "creditFacade()": FunctionFragment;
    "creditManager()": FunctionFragment;
    "emergencyLiquidators()": FunctionFragment;
    "forbidAdapter(address)": FunctionFragment;
    "forbidBorrowing()": FunctionFragment;
    "forbidToken(address)": FunctionFragment;
    "makeTokenQuoted(address)": FunctionFragment;
    "rampLiquidationThreshold(address,uint16,uint40,uint24)": FunctionFragment;
    "removeEmergencyLiquidator(address)": FunctionFragment;
    "resetCumulativeLoss()": FunctionFragment;
    "setBotList(uint256)": FunctionFragment;
    "setCreditFacade(address,bool)": FunctionFragment;
    "setExpirationDate(uint40)": FunctionFragment;
    "setFees(uint16,uint16,uint16,uint16,uint16)": FunctionFragment;
    "setLiquidationThreshold(address,uint16)": FunctionFragment;
    "setMaxCumulativeLoss(uint128)": FunctionFragment;
    "setMaxDebtLimit(uint128)": FunctionFragment;
    "setMaxDebtPerBlockMultiplier(uint8)": FunctionFragment;
    "setMaxEnabledTokens(uint8)": FunctionFragment;
    "setMinDebtLimit(uint128)": FunctionFragment;
    "setPriceOracle(uint256)": FunctionFragment;
    "setTotalDebtLimit(uint128)": FunctionFragment;
    "setTotalDebtParams(uint128,uint128)": FunctionFragment;
    "underlying()": FunctionFragment;
    "upgradeCreditConfigurator(address)": FunctionFragment;
    "version()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addCollateralToken"
      | "addEmergencyLiquidator"
      | "addressProvider"
      | "allowAdapter"
      | "allowToken"
      | "allowedAdapters"
      | "creditFacade"
      | "creditManager"
      | "emergencyLiquidators"
      | "forbidAdapter"
      | "forbidBorrowing"
      | "forbidToken"
      | "makeTokenQuoted"
      | "rampLiquidationThreshold"
      | "removeEmergencyLiquidator"
      | "resetCumulativeLoss"
      | "setBotList"
      | "setCreditFacade"
      | "setExpirationDate"
      | "setFees"
      | "setLiquidationThreshold"
      | "setMaxCumulativeLoss"
      | "setMaxDebtLimit"
      | "setMaxDebtPerBlockMultiplier"
      | "setMaxEnabledTokens"
      | "setMinDebtLimit"
      | "setPriceOracle"
      | "setTotalDebtLimit"
      | "setTotalDebtParams"
      | "underlying"
      | "upgradeCreditConfigurator"
      | "version"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addCollateralToken",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "addEmergencyLiquidator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addressProvider",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allowAdapter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "allowToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "allowedAdapters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "creditFacade",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "creditManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyLiquidators",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "forbidAdapter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "forbidBorrowing",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "forbidToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "makeTokenQuoted",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "rampLiquidationThreshold",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "removeEmergencyLiquidator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "resetCumulativeLoss",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setBotList",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCreditFacade",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpirationDate",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFees",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setLiquidationThreshold",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxCumulativeLoss",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxDebtLimit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxDebtPerBlockMultiplier",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxEnabledTokens",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinDebtLimit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOracle",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTotalDebtLimit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTotalDebtParams",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "underlying",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeCreditConfigurator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "addCollateralToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addEmergencyLiquidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addressProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allowAdapter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "allowToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "allowedAdapters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creditFacade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creditManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyLiquidators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forbidAdapter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forbidBorrowing",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forbidToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "makeTokenQuoted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rampLiquidationThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeEmergencyLiquidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "resetCumulativeLoss",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setBotList", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setCreditFacade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setFees", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setLiquidationThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxCumulativeLoss",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxDebtLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxDebtPerBlockMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxEnabledTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinDebtLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTotalDebtLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTotalDebtParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "underlying", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeCreditConfigurator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;

  events: {
    "AddEmergencyLiquidator(address)": EventFragment;
    "AllowAdapter(address,address)": EventFragment;
    "AllowBorrowing()": EventFragment;
    "AllowToken(address)": EventFragment;
    "CreditConfiguratorUpgraded(address)": EventFragment;
    "ForbidAdapter(address,address)": EventFragment;
    "ForbidBorrowing()": EventFragment;
    "ForbidToken(address)": EventFragment;
    "QuoteToken(address)": EventFragment;
    "RemoveEmergencyLiquidator(address)": EventFragment;
    "ResetCumulativeLoss()": EventFragment;
    "ScheduleTokenLiquidationThresholdRamp(address,uint16,uint16,uint40,uint40)": EventFragment;
    "SetBorrowingLimits(uint256,uint256)": EventFragment;
    "SetBotList(address)": EventFragment;
    "SetCreditFacade(address)": EventFragment;
    "SetExpirationDate(uint40)": EventFragment;
    "SetMaxCumulativeLoss(uint128)": EventFragment;
    "SetMaxDebtPerBlockMultiplier(uint8)": EventFragment;
    "SetMaxEnabledTokens(uint8)": EventFragment;
    "SetPriceOracle(address)": EventFragment;
    "SetTokenLiquidationThreshold(address,uint16)": EventFragment;
    "SetTotalDebtLimit(uint128)": EventFragment;
    "UpdateFees(uint16,uint16,uint16,uint16,uint16)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AddEmergencyLiquidator"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowAdapter"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowBorrowing"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreditConfiguratorUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ForbidAdapter"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ForbidBorrowing"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ForbidToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QuoteToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RemoveEmergencyLiquidator"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ResetCumulativeLoss"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ScheduleTokenLiquidationThresholdRamp"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetBorrowingLimits"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetBotList"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetCreditFacade"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetExpirationDate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetMaxCumulativeLoss"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "SetMaxDebtPerBlockMultiplier"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetMaxEnabledTokens"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetPriceOracle"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "SetTokenLiquidationThreshold"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetTotalDebtLimit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateFees"): EventFragment;
}

export interface AddEmergencyLiquidatorEventObject {
  arg0: string;
}
export type AddEmergencyLiquidatorEvent = TypedEvent<
  [string],
  AddEmergencyLiquidatorEventObject
>;

export type AddEmergencyLiquidatorEventFilter =
  TypedEventFilter<AddEmergencyLiquidatorEvent>;

export interface AllowAdapterEventObject {
  targetContract: string;
  adapter: string;
}
export type AllowAdapterEvent = TypedEvent<
  [string, string],
  AllowAdapterEventObject
>;

export type AllowAdapterEventFilter = TypedEventFilter<AllowAdapterEvent>;

export interface AllowBorrowingEventObject {}
export type AllowBorrowingEvent = TypedEvent<[], AllowBorrowingEventObject>;

export type AllowBorrowingEventFilter = TypedEventFilter<AllowBorrowingEvent>;

export interface AllowTokenEventObject {
  token: string;
}
export type AllowTokenEvent = TypedEvent<[string], AllowTokenEventObject>;

export type AllowTokenEventFilter = TypedEventFilter<AllowTokenEvent>;

export interface CreditConfiguratorUpgradedEventObject {
  newCreditConfigurator: string;
}
export type CreditConfiguratorUpgradedEvent = TypedEvent<
  [string],
  CreditConfiguratorUpgradedEventObject
>;

export type CreditConfiguratorUpgradedEventFilter =
  TypedEventFilter<CreditConfiguratorUpgradedEvent>;

export interface ForbidAdapterEventObject {
  targetContract: string;
  adapter: string;
}
export type ForbidAdapterEvent = TypedEvent<
  [string, string],
  ForbidAdapterEventObject
>;

export type ForbidAdapterEventFilter = TypedEventFilter<ForbidAdapterEvent>;

export interface ForbidBorrowingEventObject {}
export type ForbidBorrowingEvent = TypedEvent<[], ForbidBorrowingEventObject>;

export type ForbidBorrowingEventFilter = TypedEventFilter<ForbidBorrowingEvent>;

export interface ForbidTokenEventObject {
  token: string;
}
export type ForbidTokenEvent = TypedEvent<[string], ForbidTokenEventObject>;

export type ForbidTokenEventFilter = TypedEventFilter<ForbidTokenEvent>;

export interface QuoteTokenEventObject {
  arg0: string;
}
export type QuoteTokenEvent = TypedEvent<[string], QuoteTokenEventObject>;

export type QuoteTokenEventFilter = TypedEventFilter<QuoteTokenEvent>;

export interface RemoveEmergencyLiquidatorEventObject {
  arg0: string;
}
export type RemoveEmergencyLiquidatorEvent = TypedEvent<
  [string],
  RemoveEmergencyLiquidatorEventObject
>;

export type RemoveEmergencyLiquidatorEventFilter =
  TypedEventFilter<RemoveEmergencyLiquidatorEvent>;

export interface ResetCumulativeLossEventObject {}
export type ResetCumulativeLossEvent = TypedEvent<
  [],
  ResetCumulativeLossEventObject
>;

export type ResetCumulativeLossEventFilter =
  TypedEventFilter<ResetCumulativeLossEvent>;

export interface ScheduleTokenLiquidationThresholdRampEventObject {
  token: string;
  liquidationThresholdInitial: number;
  liquidationThresholdFinal: number;
  timestampRampStart: number;
  timestampRampEnd: number;
}
export type ScheduleTokenLiquidationThresholdRampEvent = TypedEvent<
  [string, number, number, number, number],
  ScheduleTokenLiquidationThresholdRampEventObject
>;

export type ScheduleTokenLiquidationThresholdRampEventFilter =
  TypedEventFilter<ScheduleTokenLiquidationThresholdRampEvent>;

export interface SetBorrowingLimitsEventObject {
  minDebt: BigNumber;
  maxDebt: BigNumber;
}
export type SetBorrowingLimitsEvent = TypedEvent<
  [BigNumber, BigNumber],
  SetBorrowingLimitsEventObject
>;

export type SetBorrowingLimitsEventFilter =
  TypedEventFilter<SetBorrowingLimitsEvent>;

export interface SetBotListEventObject {
  arg0: string;
}
export type SetBotListEvent = TypedEvent<[string], SetBotListEventObject>;

export type SetBotListEventFilter = TypedEventFilter<SetBotListEvent>;

export interface SetCreditFacadeEventObject {
  newCreditFacade: string;
}
export type SetCreditFacadeEvent = TypedEvent<
  [string],
  SetCreditFacadeEventObject
>;

export type SetCreditFacadeEventFilter = TypedEventFilter<SetCreditFacadeEvent>;

export interface SetExpirationDateEventObject {
  arg0: number;
}
export type SetExpirationDateEvent = TypedEvent<
  [number],
  SetExpirationDateEventObject
>;

export type SetExpirationDateEventFilter =
  TypedEventFilter<SetExpirationDateEvent>;

export interface SetMaxCumulativeLossEventObject {
  arg0: BigNumber;
}
export type SetMaxCumulativeLossEvent = TypedEvent<
  [BigNumber],
  SetMaxCumulativeLossEventObject
>;

export type SetMaxCumulativeLossEventFilter =
  TypedEventFilter<SetMaxCumulativeLossEvent>;

export interface SetMaxDebtPerBlockMultiplierEventObject {
  arg0: number;
}
export type SetMaxDebtPerBlockMultiplierEvent = TypedEvent<
  [number],
  SetMaxDebtPerBlockMultiplierEventObject
>;

export type SetMaxDebtPerBlockMultiplierEventFilter =
  TypedEventFilter<SetMaxDebtPerBlockMultiplierEvent>;

export interface SetMaxEnabledTokensEventObject {
  arg0: number;
}
export type SetMaxEnabledTokensEvent = TypedEvent<
  [number],
  SetMaxEnabledTokensEventObject
>;

export type SetMaxEnabledTokensEventFilter =
  TypedEventFilter<SetMaxEnabledTokensEvent>;

export interface SetPriceOracleEventObject {
  newPriceOracle: string;
}
export type SetPriceOracleEvent = TypedEvent<
  [string],
  SetPriceOracleEventObject
>;

export type SetPriceOracleEventFilter = TypedEventFilter<SetPriceOracleEvent>;

export interface SetTokenLiquidationThresholdEventObject {
  token: string;
  liquidationThreshold: number;
}
export type SetTokenLiquidationThresholdEvent = TypedEvent<
  [string, number],
  SetTokenLiquidationThresholdEventObject
>;

export type SetTokenLiquidationThresholdEventFilter =
  TypedEventFilter<SetTokenLiquidationThresholdEvent>;

export interface SetTotalDebtLimitEventObject {
  arg0: BigNumber;
}
export type SetTotalDebtLimitEvent = TypedEvent<
  [BigNumber],
  SetTotalDebtLimitEventObject
>;

export type SetTotalDebtLimitEventFilter =
  TypedEventFilter<SetTotalDebtLimitEvent>;

export interface UpdateFeesEventObject {
  feeInterest: number;
  feeLiquidation: number;
  liquidationPremium: number;
  feeLiquidationExpired: number;
  liquidationPremiumExpired: number;
}
export type UpdateFeesEvent = TypedEvent<
  [number, number, number, number, number],
  UpdateFeesEventObject
>;

export type UpdateFeesEventFilter = TypedEventFilter<UpdateFeesEvent>;

export interface ICreditConfiguratorV3 extends BaseContract {
  contractName: "ICreditConfiguratorV3";

  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ICreditConfiguratorV3Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addCollateralToken(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addressProvider(overrides?: CallOverrides): Promise<[string]>;

    allowAdapter(
      adapter: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    allowToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    allowedAdapters(overrides?: CallOverrides): Promise<[string[]]>;

    creditFacade(overrides?: CallOverrides): Promise<[string]>;

    creditManager(overrides?: CallOverrides): Promise<[string]>;

    emergencyLiquidators(overrides?: CallOverrides): Promise<[string[]]>;

    forbidAdapter(
      targetContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forbidBorrowing(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forbidToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    makeTokenQuoted(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rampLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThresholdFinal: PromiseOrValue<BigNumberish>,
      rampStart: PromiseOrValue<BigNumberish>,
      rampDuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    resetCumulativeLoss(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBotList(
      version: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCreditFacade(
      creditFacade: PromiseOrValue<string>,
      migrateParams: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setExpirationDate(
      newExpirationDate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFees(
      feeInterest: PromiseOrValue<BigNumberish>,
      feeLiquidation: PromiseOrValue<BigNumberish>,
      liquidationPremium: PromiseOrValue<BigNumberish>,
      feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      liquidationPremiumExpired: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxCumulativeLoss(
      _maxCumulativeLoss: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxDebtLimit(
      maxDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxDebtPerBlockMultiplier(
      newMaxDebtLimitPerBlockMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxEnabledTokens(
      maxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMinDebtLimit(
      minDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPriceOracle(
      version: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTotalDebtLimit(
      newLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTotalDebtParams(
      newCurrentTotalDebt: PromiseOrValue<BigNumberish>,
      newLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    underlying(overrides?: CallOverrides): Promise<[string]>;

    upgradeCreditConfigurator(
      creditConfigurator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    version(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  addCollateralToken(
    token: PromiseOrValue<string>,
    liquidationThreshold: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addEmergencyLiquidator(
    liquidator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addressProvider(overrides?: CallOverrides): Promise<string>;

  allowAdapter(
    adapter: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  allowToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  allowedAdapters(overrides?: CallOverrides): Promise<string[]>;

  creditFacade(overrides?: CallOverrides): Promise<string>;

  creditManager(overrides?: CallOverrides): Promise<string>;

  emergencyLiquidators(overrides?: CallOverrides): Promise<string[]>;

  forbidAdapter(
    targetContract: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forbidBorrowing(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forbidToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  makeTokenQuoted(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rampLiquidationThreshold(
    token: PromiseOrValue<string>,
    liquidationThresholdFinal: PromiseOrValue<BigNumberish>,
    rampStart: PromiseOrValue<BigNumberish>,
    rampDuration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeEmergencyLiquidator(
    liquidator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  resetCumulativeLoss(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBotList(
    version: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCreditFacade(
    creditFacade: PromiseOrValue<string>,
    migrateParams: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setExpirationDate(
    newExpirationDate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFees(
    feeInterest: PromiseOrValue<BigNumberish>,
    feeLiquidation: PromiseOrValue<BigNumberish>,
    liquidationPremium: PromiseOrValue<BigNumberish>,
    feeLiquidationExpired: PromiseOrValue<BigNumberish>,
    liquidationPremiumExpired: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setLiquidationThreshold(
    token: PromiseOrValue<string>,
    liquidationThreshold: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxCumulativeLoss(
    _maxCumulativeLoss: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxDebtLimit(
    maxDebt: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxDebtPerBlockMultiplier(
    newMaxDebtLimitPerBlockMultiplier: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxEnabledTokens(
    maxEnabledTokens: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMinDebtLimit(
    minDebt: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPriceOracle(
    version: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTotalDebtLimit(
    newLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTotalDebtParams(
    newCurrentTotalDebt: PromiseOrValue<BigNumberish>,
    newLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  underlying(overrides?: CallOverrides): Promise<string>;

  upgradeCreditConfigurator(
    creditConfigurator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  version(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    addCollateralToken(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    addEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addressProvider(overrides?: CallOverrides): Promise<string>;

    allowAdapter(
      adapter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    allowToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    allowedAdapters(overrides?: CallOverrides): Promise<string[]>;

    creditFacade(overrides?: CallOverrides): Promise<string>;

    creditManager(overrides?: CallOverrides): Promise<string>;

    emergencyLiquidators(overrides?: CallOverrides): Promise<string[]>;

    forbidAdapter(
      targetContract: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    forbidBorrowing(overrides?: CallOverrides): Promise<void>;

    forbidToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    makeTokenQuoted(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    rampLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThresholdFinal: PromiseOrValue<BigNumberish>,
      rampStart: PromiseOrValue<BigNumberish>,
      rampDuration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    resetCumulativeLoss(overrides?: CallOverrides): Promise<void>;

    setBotList(
      version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCreditFacade(
      creditFacade: PromiseOrValue<string>,
      migrateParams: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setExpirationDate(
      newExpirationDate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setFees(
      feeInterest: PromiseOrValue<BigNumberish>,
      feeLiquidation: PromiseOrValue<BigNumberish>,
      liquidationPremium: PromiseOrValue<BigNumberish>,
      feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      liquidationPremiumExpired: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxCumulativeLoss(
      _maxCumulativeLoss: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxDebtLimit(
      maxDebt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxDebtPerBlockMultiplier(
      newMaxDebtLimitPerBlockMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxEnabledTokens(
      maxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinDebtLimit(
      minDebt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPriceOracle(
      version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTotalDebtLimit(
      newLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTotalDebtParams(
      newCurrentTotalDebt: PromiseOrValue<BigNumberish>,
      newLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    underlying(overrides?: CallOverrides): Promise<string>;

    upgradeCreditConfigurator(
      creditConfigurator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    version(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    "AddEmergencyLiquidator(address)"(
      arg0?: null
    ): AddEmergencyLiquidatorEventFilter;
    AddEmergencyLiquidator(arg0?: null): AddEmergencyLiquidatorEventFilter;

    "AllowAdapter(address,address)"(
      targetContract?: PromiseOrValue<string> | null,
      adapter?: PromiseOrValue<string> | null
    ): AllowAdapterEventFilter;
    AllowAdapter(
      targetContract?: PromiseOrValue<string> | null,
      adapter?: PromiseOrValue<string> | null
    ): AllowAdapterEventFilter;

    "AllowBorrowing()"(): AllowBorrowingEventFilter;
    AllowBorrowing(): AllowBorrowingEventFilter;

    "AllowToken(address)"(
      token?: PromiseOrValue<string> | null
    ): AllowTokenEventFilter;
    AllowToken(token?: PromiseOrValue<string> | null): AllowTokenEventFilter;

    "CreditConfiguratorUpgraded(address)"(
      newCreditConfigurator?: PromiseOrValue<string> | null
    ): CreditConfiguratorUpgradedEventFilter;
    CreditConfiguratorUpgraded(
      newCreditConfigurator?: PromiseOrValue<string> | null
    ): CreditConfiguratorUpgradedEventFilter;

    "ForbidAdapter(address,address)"(
      targetContract?: PromiseOrValue<string> | null,
      adapter?: PromiseOrValue<string> | null
    ): ForbidAdapterEventFilter;
    ForbidAdapter(
      targetContract?: PromiseOrValue<string> | null,
      adapter?: PromiseOrValue<string> | null
    ): ForbidAdapterEventFilter;

    "ForbidBorrowing()"(): ForbidBorrowingEventFilter;
    ForbidBorrowing(): ForbidBorrowingEventFilter;

    "ForbidToken(address)"(
      token?: PromiseOrValue<string> | null
    ): ForbidTokenEventFilter;
    ForbidToken(token?: PromiseOrValue<string> | null): ForbidTokenEventFilter;

    "QuoteToken(address)"(arg0?: null): QuoteTokenEventFilter;
    QuoteToken(arg0?: null): QuoteTokenEventFilter;

    "RemoveEmergencyLiquidator(address)"(
      arg0?: null
    ): RemoveEmergencyLiquidatorEventFilter;
    RemoveEmergencyLiquidator(
      arg0?: null
    ): RemoveEmergencyLiquidatorEventFilter;

    "ResetCumulativeLoss()"(): ResetCumulativeLossEventFilter;
    ResetCumulativeLoss(): ResetCumulativeLossEventFilter;

    "ScheduleTokenLiquidationThresholdRamp(address,uint16,uint16,uint40,uint40)"(
      token?: PromiseOrValue<string> | null,
      liquidationThresholdInitial?: null,
      liquidationThresholdFinal?: null,
      timestampRampStart?: null,
      timestampRampEnd?: null
    ): ScheduleTokenLiquidationThresholdRampEventFilter;
    ScheduleTokenLiquidationThresholdRamp(
      token?: PromiseOrValue<string> | null,
      liquidationThresholdInitial?: null,
      liquidationThresholdFinal?: null,
      timestampRampStart?: null,
      timestampRampEnd?: null
    ): ScheduleTokenLiquidationThresholdRampEventFilter;

    "SetBorrowingLimits(uint256,uint256)"(
      minDebt?: null,
      maxDebt?: null
    ): SetBorrowingLimitsEventFilter;
    SetBorrowingLimits(
      minDebt?: null,
      maxDebt?: null
    ): SetBorrowingLimitsEventFilter;

    "SetBotList(address)"(arg0?: null): SetBotListEventFilter;
    SetBotList(arg0?: null): SetBotListEventFilter;

    "SetCreditFacade(address)"(
      newCreditFacade?: PromiseOrValue<string> | null
    ): SetCreditFacadeEventFilter;
    SetCreditFacade(
      newCreditFacade?: PromiseOrValue<string> | null
    ): SetCreditFacadeEventFilter;

    "SetExpirationDate(uint40)"(arg0?: null): SetExpirationDateEventFilter;
    SetExpirationDate(arg0?: null): SetExpirationDateEventFilter;

    "SetMaxCumulativeLoss(uint128)"(
      arg0?: null
    ): SetMaxCumulativeLossEventFilter;
    SetMaxCumulativeLoss(arg0?: null): SetMaxCumulativeLossEventFilter;

    "SetMaxDebtPerBlockMultiplier(uint8)"(
      arg0?: null
    ): SetMaxDebtPerBlockMultiplierEventFilter;
    SetMaxDebtPerBlockMultiplier(
      arg0?: null
    ): SetMaxDebtPerBlockMultiplierEventFilter;

    "SetMaxEnabledTokens(uint8)"(arg0?: null): SetMaxEnabledTokensEventFilter;
    SetMaxEnabledTokens(arg0?: null): SetMaxEnabledTokensEventFilter;

    "SetPriceOracle(address)"(
      newPriceOracle?: PromiseOrValue<string> | null
    ): SetPriceOracleEventFilter;
    SetPriceOracle(
      newPriceOracle?: PromiseOrValue<string> | null
    ): SetPriceOracleEventFilter;

    "SetTokenLiquidationThreshold(address,uint16)"(
      token?: PromiseOrValue<string> | null,
      liquidationThreshold?: null
    ): SetTokenLiquidationThresholdEventFilter;
    SetTokenLiquidationThreshold(
      token?: PromiseOrValue<string> | null,
      liquidationThreshold?: null
    ): SetTokenLiquidationThresholdEventFilter;

    "SetTotalDebtLimit(uint128)"(arg0?: null): SetTotalDebtLimitEventFilter;
    SetTotalDebtLimit(arg0?: null): SetTotalDebtLimitEventFilter;

    "UpdateFees(uint16,uint16,uint16,uint16,uint16)"(
      feeInterest?: null,
      feeLiquidation?: null,
      liquidationPremium?: null,
      feeLiquidationExpired?: null,
      liquidationPremiumExpired?: null
    ): UpdateFeesEventFilter;
    UpdateFees(
      feeInterest?: null,
      feeLiquidation?: null,
      liquidationPremium?: null,
      feeLiquidationExpired?: null,
      liquidationPremiumExpired?: null
    ): UpdateFeesEventFilter;
  };

  estimateGas: {
    addCollateralToken(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addressProvider(overrides?: CallOverrides): Promise<BigNumber>;

    allowAdapter(
      adapter: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    allowToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    allowedAdapters(overrides?: CallOverrides): Promise<BigNumber>;

    creditFacade(overrides?: CallOverrides): Promise<BigNumber>;

    creditManager(overrides?: CallOverrides): Promise<BigNumber>;

    emergencyLiquidators(overrides?: CallOverrides): Promise<BigNumber>;

    forbidAdapter(
      targetContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forbidBorrowing(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forbidToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    makeTokenQuoted(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rampLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThresholdFinal: PromiseOrValue<BigNumberish>,
      rampStart: PromiseOrValue<BigNumberish>,
      rampDuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    resetCumulativeLoss(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBotList(
      version: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCreditFacade(
      creditFacade: PromiseOrValue<string>,
      migrateParams: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setExpirationDate(
      newExpirationDate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFees(
      feeInterest: PromiseOrValue<BigNumberish>,
      feeLiquidation: PromiseOrValue<BigNumberish>,
      liquidationPremium: PromiseOrValue<BigNumberish>,
      feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      liquidationPremiumExpired: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxCumulativeLoss(
      _maxCumulativeLoss: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxDebtLimit(
      maxDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxDebtPerBlockMultiplier(
      newMaxDebtLimitPerBlockMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxEnabledTokens(
      maxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMinDebtLimit(
      minDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPriceOracle(
      version: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTotalDebtLimit(
      newLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTotalDebtParams(
      newCurrentTotalDebt: PromiseOrValue<BigNumberish>,
      newLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    underlying(overrides?: CallOverrides): Promise<BigNumber>;

    upgradeCreditConfigurator(
      creditConfigurator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    addCollateralToken(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addressProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allowAdapter(
      adapter: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    allowToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    allowedAdapters(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    creditFacade(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    creditManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emergencyLiquidators(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    forbidAdapter(
      targetContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forbidBorrowing(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forbidToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    makeTokenQuoted(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rampLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThresholdFinal: PromiseOrValue<BigNumberish>,
      rampStart: PromiseOrValue<BigNumberish>,
      rampDuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeEmergencyLiquidator(
      liquidator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    resetCumulativeLoss(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBotList(
      version: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCreditFacade(
      creditFacade: PromiseOrValue<string>,
      migrateParams: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setExpirationDate(
      newExpirationDate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFees(
      feeInterest: PromiseOrValue<BigNumberish>,
      feeLiquidation: PromiseOrValue<BigNumberish>,
      liquidationPremium: PromiseOrValue<BigNumberish>,
      feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      liquidationPremiumExpired: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setLiquidationThreshold(
      token: PromiseOrValue<string>,
      liquidationThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxCumulativeLoss(
      _maxCumulativeLoss: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxDebtLimit(
      maxDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxDebtPerBlockMultiplier(
      newMaxDebtLimitPerBlockMultiplier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxEnabledTokens(
      maxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMinDebtLimit(
      minDebt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPriceOracle(
      version: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTotalDebtLimit(
      newLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTotalDebtParams(
      newCurrentTotalDebt: PromiseOrValue<BigNumberish>,
      newLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    underlying(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    upgradeCreditConfigurator(
      creditConfigurator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
