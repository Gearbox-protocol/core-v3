/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type CollateralDebtDataStruct = {
  debt: PromiseOrValue<BigNumberish>;
  cumulativeIndexNow: PromiseOrValue<BigNumberish>;
  cumulativeIndexLastUpdate: PromiseOrValue<BigNumberish>;
  cumulativeQuotaInterest: PromiseOrValue<BigNumberish>;
  accruedInterest: PromiseOrValue<BigNumberish>;
  accruedFees: PromiseOrValue<BigNumberish>;
  totalDebtUSD: PromiseOrValue<BigNumberish>;
  totalValue: PromiseOrValue<BigNumberish>;
  totalValueUSD: PromiseOrValue<BigNumberish>;
  twvUSD: PromiseOrValue<BigNumberish>;
  enabledTokensMask: PromiseOrValue<BigNumberish>;
  quotedTokensMask: PromiseOrValue<BigNumberish>;
  quotedTokens: PromiseOrValue<string>[];
  _poolQuotaKeeper: PromiseOrValue<string>;
};

export type CollateralDebtDataStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  string[],
  string
] & {
  debt: BigNumber;
  cumulativeIndexNow: BigNumber;
  cumulativeIndexLastUpdate: BigNumber;
  cumulativeQuotaInterest: BigNumber;
  accruedInterest: BigNumber;
  accruedFees: BigNumber;
  totalDebtUSD: BigNumber;
  totalValue: BigNumber;
  totalValueUSD: BigNumber;
  twvUSD: BigNumber;
  enabledTokensMask: BigNumber;
  quotedTokensMask: BigNumber;
  quotedTokens: string[];
  _poolQuotaKeeper: string;
};

export type RevocationPairStruct = {
  spender: PromiseOrValue<string>;
  token: PromiseOrValue<string>;
};

export type RevocationPairStructOutput = [string, string] & {
  spender: string;
  token: string;
};

export interface CreditManagerV3_USDTInterface extends utils.Interface {
  functions: {
    "accountFactory()": FunctionFragment;
    "adapterToContract(address)": FunctionFragment;
    "addCollateral(address,address,address,uint256)": FunctionFragment;
    "addToken(address)": FunctionFragment;
    "addressProvider()": FunctionFragment;
    "approveCreditAccount(address,uint256)": FunctionFragment;
    "calcDebtAndCollateral(address,uint8)": FunctionFragment;
    "claimWithdrawals(address,address,uint8)": FunctionFragment;
    "closeCreditAccount(address,uint8,(uint256,uint256,uint256,uint128,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address[],address),address,address,uint256,bool)": FunctionFragment;
    "collateralTokenByMask(uint256)": FunctionFragment;
    "collateralTokensCount()": FunctionFragment;
    "contractToAdapter(address)": FunctionFragment;
    "creditAccountInfo(address)": FunctionFragment;
    "creditAccounts()": FunctionFragment;
    "creditConfigurator()": FunctionFragment;
    "creditFacade()": FunctionFragment;
    "enabledTokensMaskOf(address)": FunctionFragment;
    "execute(bytes)": FunctionFragment;
    "fees()": FunctionFragment;
    "flagsOf(address)": FunctionFragment;
    "fullCollateralCheck(address,uint256,uint256[],uint16)": FunctionFragment;
    "getActiveCreditAccountOrRevert()": FunctionFragment;
    "getBorrowerOrRevert(address)": FunctionFragment;
    "getTokenByMask(uint256)": FunctionFragment;
    "getTokenMaskOrRevert(address)": FunctionFragment;
    "isLiquidatable(address,uint16)": FunctionFragment;
    "liquidationThresholds(address)": FunctionFragment;
    "manageDebt(address,uint256,uint256,uint8)": FunctionFragment;
    "maxEnabledTokens()": FunctionFragment;
    "openCreditAccount(uint256,address)": FunctionFragment;
    "pool()": FunctionFragment;
    "poolQuotaKeeper()": FunctionFragment;
    "poolService()": FunctionFragment;
    "priceOracle()": FunctionFragment;
    "quotedTokensMask()": FunctionFragment;
    "revokeAdapterAllowances(address,(address,address)[])": FunctionFragment;
    "scheduleWithdrawal(address,address,uint256)": FunctionFragment;
    "setActiveCreditAccount(address)": FunctionFragment;
    "setCollateralTokenData(address,uint16,uint16,uint40,uint24)": FunctionFragment;
    "setContractAllowance(address,address)": FunctionFragment;
    "setCreditConfigurator(address)": FunctionFragment;
    "setCreditFacade(address)": FunctionFragment;
    "setFees(uint16,uint16,uint16,uint16,uint16)": FunctionFragment;
    "setFlagFor(address,uint16,bool)": FunctionFragment;
    "setMaxEnabledTokens(uint8)": FunctionFragment;
    "setPriceOracle(address)": FunctionFragment;
    "setQuotedMask(uint256)": FunctionFragment;
    "supportsQuotas()": FunctionFragment;
    "underlying()": FunctionFragment;
    "updateQuota(address,address,int96,uint96,uint96)": FunctionFragment;
    "version()": FunctionFragment;
    "weth()": FunctionFragment;
    "withdrawalManager()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "accountFactory"
      | "adapterToContract"
      | "addCollateral"
      | "addToken"
      | "addressProvider"
      | "approveCreditAccount"
      | "calcDebtAndCollateral"
      | "claimWithdrawals"
      | "closeCreditAccount"
      | "collateralTokenByMask"
      | "collateralTokensCount"
      | "contractToAdapter"
      | "creditAccountInfo"
      | "creditAccounts"
      | "creditConfigurator"
      | "creditFacade"
      | "enabledTokensMaskOf"
      | "execute"
      | "fees"
      | "flagsOf"
      | "fullCollateralCheck"
      | "getActiveCreditAccountOrRevert"
      | "getBorrowerOrRevert"
      | "getTokenByMask"
      | "getTokenMaskOrRevert"
      | "isLiquidatable"
      | "liquidationThresholds"
      | "manageDebt"
      | "maxEnabledTokens"
      | "openCreditAccount"
      | "pool"
      | "poolQuotaKeeper"
      | "poolService"
      | "priceOracle"
      | "quotedTokensMask"
      | "revokeAdapterAllowances"
      | "scheduleWithdrawal"
      | "setActiveCreditAccount"
      | "setCollateralTokenData"
      | "setContractAllowance"
      | "setCreditConfigurator"
      | "setCreditFacade"
      | "setFees"
      | "setFlagFor"
      | "setMaxEnabledTokens"
      | "setPriceOracle"
      | "setQuotedMask"
      | "supportsQuotas"
      | "underlying"
      | "updateQuota"
      | "version"
      | "weth"
      | "withdrawalManager"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "accountFactory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "adapterToContract",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addCollateral",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addressProvider",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approveCreditAccount",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "calcDebtAndCollateral",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "claimWithdrawals",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "closeCreditAccount",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      CollateralDebtDataStruct,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "collateralTokenByMask",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "collateralTokensCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "contractToAdapter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "creditAccountInfo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "creditAccounts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "creditConfigurator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "creditFacade",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "enabledTokensMaskOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "fees", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "flagsOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "fullCollateralCheck",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveCreditAccountOrRevert",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBorrowerOrRevert",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenByMask",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenMaskOrRevert",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isLiquidatable",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidationThresholds",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "manageDebt",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "maxEnabledTokens",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "openCreditAccount",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "pool", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "poolQuotaKeeper",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "poolService",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "priceOracle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "quotedTokensMask",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "revokeAdapterAllowances",
    values: [PromiseOrValue<string>, RevocationPairStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "scheduleWithdrawal",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setActiveCreditAccount",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCollateralTokenData",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setContractAllowance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCreditConfigurator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCreditFacade",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFees",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setFlagFor",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxEnabledTokens",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOracle",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setQuotedMask",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsQuotas",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "underlying",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateQuota",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(functionFragment: "weth", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdrawalManager",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "accountFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "adapterToContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "addressProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveCreditAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calcDebtAndCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimWithdrawals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closeCreditAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralTokenByMask",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralTokensCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contractToAdapter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creditAccountInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creditAccounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creditConfigurator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creditFacade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enabledTokensMaskOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fees", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "flagsOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fullCollateralCheck",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveCreditAccountOrRevert",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBorrowerOrRevert",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenByMask",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenMaskOrRevert",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isLiquidatable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidationThresholds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "manageDebt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "maxEnabledTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "openCreditAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "poolQuotaKeeper",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "poolService",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "quotedTokensMask",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revokeAdapterAllowances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "scheduleWithdrawal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setActiveCreditAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCollateralTokenData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setContractAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCreditConfigurator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCreditFacade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setFees", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setFlagFor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setMaxEnabledTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setQuotedMask",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsQuotas",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "underlying", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateQuota",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "weth", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawalManager",
    data: BytesLike
  ): Result;

  events: {
    "SetCreditConfigurator(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "SetCreditConfigurator"): EventFragment;
}

export interface SetCreditConfiguratorEventObject {
  newConfigurator: string;
}
export type SetCreditConfiguratorEvent = TypedEvent<
  [string],
  SetCreditConfiguratorEventObject
>;

export type SetCreditConfiguratorEventFilter =
  TypedEventFilter<SetCreditConfiguratorEvent>;

export interface CreditManagerV3_USDT extends BaseContract {
  contractName: "CreditManagerV3_USDT";

  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CreditManagerV3_USDTInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    accountFactory(overrides?: CallOverrides): Promise<[string]>;

    adapterToContract(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    addCollateral(
      payer: PromiseOrValue<string>,
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addressProvider(overrides?: CallOverrides): Promise<[string]>;

    approveCreditAccount(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    calcDebtAndCollateral(
      creditAccount: PromiseOrValue<string>,
      task: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [CollateralDebtDataStructOutput] & {
        collateralDebtData: CollateralDebtDataStructOutput;
      }
    >;

    claimWithdrawals(
      creditAccount: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      action: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    closeCreditAccount(
      creditAccount: PromiseOrValue<string>,
      closureAction: PromiseOrValue<BigNumberish>,
      collateralDebtData: CollateralDebtDataStruct,
      payer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      skipTokensMask: PromiseOrValue<BigNumberish>,
      convertToETH: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    collateralTokenByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, number] & { token: string; liquidationThreshold: number }
    >;

    collateralTokensCount(overrides?: CallOverrides): Promise<[number]>;

    contractToAdapter(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    creditAccountInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        BigNumber,
        string
      ] & {
        debt: BigNumber;
        cumulativeIndexLastUpdate: BigNumber;
        cumulativeQuotaInterest: BigNumber;
        quotaFees: BigNumber;
        enabledTokensMask: BigNumber;
        flags: number;
        since: BigNumber;
        borrower: string;
      }
    >;

    creditAccounts(overrides?: CallOverrides): Promise<[string[]]>;

    creditConfigurator(overrides?: CallOverrides): Promise<[string]>;

    creditFacade(overrides?: CallOverrides): Promise<[string]>;

    enabledTokensMaskOf(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    execute(
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fees(
      overrides?: CallOverrides
    ): Promise<
      [number, number, number, number, number] & {
        _feeInterest: number;
        _feeLiquidation: number;
        _liquidationDiscount: number;
        _feeLiquidationExpired: number;
        _liquidationDiscountExpired: number;
      }
    >;

    flagsOf(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    fullCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      enabledTokensMask: PromiseOrValue<BigNumberish>,
      collateralHints: PromiseOrValue<BigNumberish>[],
      minHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getActiveCreditAccountOrRevert(
      overrides?: CallOverrides
    ): Promise<[string] & { creditAccount: string }>;

    getBorrowerOrRevert(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string] & { borrower: string }>;

    getTokenByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { token: string }>;

    getTokenMaskOrRevert(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { tokenMask: BigNumber }>;

    isLiquidatable(
      creditAccount: PromiseOrValue<string>,
      minHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    liquidationThresholds(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number] & { lt: number }>;

    manageDebt(
      creditAccount: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      enabledTokensMask: PromiseOrValue<BigNumberish>,
      action: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    maxEnabledTokens(overrides?: CallOverrides): Promise<[number]>;

    openCreditAccount(
      debt: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    pool(overrides?: CallOverrides): Promise<[string]>;

    poolQuotaKeeper(overrides?: CallOverrides): Promise<[string]>;

    poolService(overrides?: CallOverrides): Promise<[string]>;

    priceOracle(overrides?: CallOverrides): Promise<[string]>;

    quotedTokensMask(overrides?: CallOverrides): Promise<[BigNumber]>;

    revokeAdapterAllowances(
      creditAccount: PromiseOrValue<string>,
      revocations: RevocationPairStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    scheduleWithdrawal(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setActiveCreditAccount(
      creditAccount: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCollateralTokenData(
      token: PromiseOrValue<string>,
      ltInitial: PromiseOrValue<BigNumberish>,
      ltFinal: PromiseOrValue<BigNumberish>,
      timestampRampStart: PromiseOrValue<BigNumberish>,
      rampDuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setContractAllowance(
      adapter: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCreditConfigurator(
      _creditConfigurator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCreditFacade(
      _creditFacade: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFees(
      _feeInterest: PromiseOrValue<BigNumberish>,
      _feeLiquidation: PromiseOrValue<BigNumberish>,
      _liquidationDiscount: PromiseOrValue<BigNumberish>,
      _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFlagFor(
      creditAccount: PromiseOrValue<string>,
      flag: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxEnabledTokens(
      _maxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPriceOracle(
      _priceOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setQuotedMask(
      _quotedTokensMask: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supportsQuotas(overrides?: CallOverrides): Promise<[boolean]>;

    underlying(overrides?: CallOverrides): Promise<[string]>;

    updateQuota(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      quotaChange: PromiseOrValue<BigNumberish>,
      minQuota: PromiseOrValue<BigNumberish>,
      maxQuota: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    version(overrides?: CallOverrides): Promise<[BigNumber]>;

    weth(overrides?: CallOverrides): Promise<[string]>;

    withdrawalManager(overrides?: CallOverrides): Promise<[string]>;
  };

  accountFactory(overrides?: CallOverrides): Promise<string>;

  adapterToContract(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  addCollateral(
    payer: PromiseOrValue<string>,
    creditAccount: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addressProvider(overrides?: CallOverrides): Promise<string>;

  approveCreditAccount(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  calcDebtAndCollateral(
    creditAccount: PromiseOrValue<string>,
    task: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<CollateralDebtDataStructOutput>;

  claimWithdrawals(
    creditAccount: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    action: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  closeCreditAccount(
    creditAccount: PromiseOrValue<string>,
    closureAction: PromiseOrValue<BigNumberish>,
    collateralDebtData: CollateralDebtDataStruct,
    payer: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    skipTokensMask: PromiseOrValue<BigNumberish>,
    convertToETH: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  collateralTokenByMask(
    tokenMask: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, number] & { token: string; liquidationThreshold: number }
  >;

  collateralTokensCount(overrides?: CallOverrides): Promise<number>;

  contractToAdapter(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  creditAccountInfo(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      BigNumber,
      string
    ] & {
      debt: BigNumber;
      cumulativeIndexLastUpdate: BigNumber;
      cumulativeQuotaInterest: BigNumber;
      quotaFees: BigNumber;
      enabledTokensMask: BigNumber;
      flags: number;
      since: BigNumber;
      borrower: string;
    }
  >;

  creditAccounts(overrides?: CallOverrides): Promise<string[]>;

  creditConfigurator(overrides?: CallOverrides): Promise<string>;

  creditFacade(overrides?: CallOverrides): Promise<string>;

  enabledTokensMaskOf(
    creditAccount: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  execute(
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fees(
    overrides?: CallOverrides
  ): Promise<
    [number, number, number, number, number] & {
      _feeInterest: number;
      _feeLiquidation: number;
      _liquidationDiscount: number;
      _feeLiquidationExpired: number;
      _liquidationDiscountExpired: number;
    }
  >;

  flagsOf(
    creditAccount: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  fullCollateralCheck(
    creditAccount: PromiseOrValue<string>,
    enabledTokensMask: PromiseOrValue<BigNumberish>,
    collateralHints: PromiseOrValue<BigNumberish>[],
    minHealthFactor: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getActiveCreditAccountOrRevert(overrides?: CallOverrides): Promise<string>;

  getBorrowerOrRevert(
    creditAccount: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  getTokenByMask(
    tokenMask: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getTokenMaskOrRevert(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  isLiquidatable(
    creditAccount: PromiseOrValue<string>,
    minHealthFactor: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  liquidationThresholds(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  manageDebt(
    creditAccount: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    enabledTokensMask: PromiseOrValue<BigNumberish>,
    action: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  maxEnabledTokens(overrides?: CallOverrides): Promise<number>;

  openCreditAccount(
    debt: PromiseOrValue<BigNumberish>,
    onBehalfOf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  pool(overrides?: CallOverrides): Promise<string>;

  poolQuotaKeeper(overrides?: CallOverrides): Promise<string>;

  poolService(overrides?: CallOverrides): Promise<string>;

  priceOracle(overrides?: CallOverrides): Promise<string>;

  quotedTokensMask(overrides?: CallOverrides): Promise<BigNumber>;

  revokeAdapterAllowances(
    creditAccount: PromiseOrValue<string>,
    revocations: RevocationPairStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  scheduleWithdrawal(
    creditAccount: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setActiveCreditAccount(
    creditAccount: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCollateralTokenData(
    token: PromiseOrValue<string>,
    ltInitial: PromiseOrValue<BigNumberish>,
    ltFinal: PromiseOrValue<BigNumberish>,
    timestampRampStart: PromiseOrValue<BigNumberish>,
    rampDuration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setContractAllowance(
    adapter: PromiseOrValue<string>,
    targetContract: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCreditConfigurator(
    _creditConfigurator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCreditFacade(
    _creditFacade: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFees(
    _feeInterest: PromiseOrValue<BigNumberish>,
    _feeLiquidation: PromiseOrValue<BigNumberish>,
    _liquidationDiscount: PromiseOrValue<BigNumberish>,
    _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
    _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFlagFor(
    creditAccount: PromiseOrValue<string>,
    flag: PromiseOrValue<BigNumberish>,
    value: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxEnabledTokens(
    _maxEnabledTokens: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPriceOracle(
    _priceOracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setQuotedMask(
    _quotedTokensMask: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supportsQuotas(overrides?: CallOverrides): Promise<boolean>;

  underlying(overrides?: CallOverrides): Promise<string>;

  updateQuota(
    creditAccount: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    quotaChange: PromiseOrValue<BigNumberish>,
    minQuota: PromiseOrValue<BigNumberish>,
    maxQuota: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  version(overrides?: CallOverrides): Promise<BigNumber>;

  weth(overrides?: CallOverrides): Promise<string>;

  withdrawalManager(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    accountFactory(overrides?: CallOverrides): Promise<string>;

    adapterToContract(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    addCollateral(
      payer: PromiseOrValue<string>,
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addressProvider(overrides?: CallOverrides): Promise<string>;

    approveCreditAccount(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    calcDebtAndCollateral(
      creditAccount: PromiseOrValue<string>,
      task: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<CollateralDebtDataStructOutput>;

    claimWithdrawals(
      creditAccount: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      action: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    closeCreditAccount(
      creditAccount: PromiseOrValue<string>,
      closureAction: PromiseOrValue<BigNumberish>,
      collateralDebtData: CollateralDebtDataStruct,
      payer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      skipTokensMask: PromiseOrValue<BigNumberish>,
      convertToETH: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { remainingFunds: BigNumber; loss: BigNumber }
    >;

    collateralTokenByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, number] & { token: string; liquidationThreshold: number }
    >;

    collateralTokensCount(overrides?: CallOverrides): Promise<number>;

    contractToAdapter(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    creditAccountInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        BigNumber,
        string
      ] & {
        debt: BigNumber;
        cumulativeIndexLastUpdate: BigNumber;
        cumulativeQuotaInterest: BigNumber;
        quotaFees: BigNumber;
        enabledTokensMask: BigNumber;
        flags: number;
        since: BigNumber;
        borrower: string;
      }
    >;

    creditAccounts(overrides?: CallOverrides): Promise<string[]>;

    creditConfigurator(overrides?: CallOverrides): Promise<string>;

    creditFacade(overrides?: CallOverrides): Promise<string>;

    enabledTokensMaskOf(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    execute(
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    fees(
      overrides?: CallOverrides
    ): Promise<
      [number, number, number, number, number] & {
        _feeInterest: number;
        _feeLiquidation: number;
        _liquidationDiscount: number;
        _feeLiquidationExpired: number;
        _liquidationDiscountExpired: number;
      }
    >;

    flagsOf(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    fullCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      enabledTokensMask: PromiseOrValue<BigNumberish>,
      collateralHints: PromiseOrValue<BigNumberish>[],
      minHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getActiveCreditAccountOrRevert(overrides?: CallOverrides): Promise<string>;

    getBorrowerOrRevert(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    getTokenByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getTokenMaskOrRevert(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isLiquidatable(
      creditAccount: PromiseOrValue<string>,
      minHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    liquidationThresholds(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    manageDebt(
      creditAccount: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      enabledTokensMask: PromiseOrValue<BigNumberish>,
      action: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        newDebt: BigNumber;
        tokensToEnable: BigNumber;
        tokensToDisable: BigNumber;
      }
    >;

    maxEnabledTokens(overrides?: CallOverrides): Promise<number>;

    openCreditAccount(
      debt: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    pool(overrides?: CallOverrides): Promise<string>;

    poolQuotaKeeper(overrides?: CallOverrides): Promise<string>;

    poolService(overrides?: CallOverrides): Promise<string>;

    priceOracle(overrides?: CallOverrides): Promise<string>;

    quotedTokensMask(overrides?: CallOverrides): Promise<BigNumber>;

    revokeAdapterAllowances(
      creditAccount: PromiseOrValue<string>,
      revocations: RevocationPairStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    scheduleWithdrawal(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setActiveCreditAccount(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCollateralTokenData(
      token: PromiseOrValue<string>,
      ltInitial: PromiseOrValue<BigNumberish>,
      ltFinal: PromiseOrValue<BigNumberish>,
      timestampRampStart: PromiseOrValue<BigNumberish>,
      rampDuration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setContractAllowance(
      adapter: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCreditConfigurator(
      _creditConfigurator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCreditFacade(
      _creditFacade: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setFees(
      _feeInterest: PromiseOrValue<BigNumberish>,
      _feeLiquidation: PromiseOrValue<BigNumberish>,
      _liquidationDiscount: PromiseOrValue<BigNumberish>,
      _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setFlagFor(
      creditAccount: PromiseOrValue<string>,
      flag: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxEnabledTokens(
      _maxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPriceOracle(
      _priceOracle: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setQuotedMask(
      _quotedTokensMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    supportsQuotas(overrides?: CallOverrides): Promise<boolean>;

    underlying(overrides?: CallOverrides): Promise<string>;

    updateQuota(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      quotaChange: PromiseOrValue<BigNumberish>,
      minQuota: PromiseOrValue<BigNumberish>,
      maxQuota: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        tokensToEnable: BigNumber;
        tokensToDisable: BigNumber;
      }
    >;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    weth(overrides?: CallOverrides): Promise<string>;

    withdrawalManager(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "SetCreditConfigurator(address)"(
      newConfigurator?: PromiseOrValue<string> | null
    ): SetCreditConfiguratorEventFilter;
    SetCreditConfigurator(
      newConfigurator?: PromiseOrValue<string> | null
    ): SetCreditConfiguratorEventFilter;
  };

  estimateGas: {
    accountFactory(overrides?: CallOverrides): Promise<BigNumber>;

    adapterToContract(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addCollateral(
      payer: PromiseOrValue<string>,
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addressProvider(overrides?: CallOverrides): Promise<BigNumber>;

    approveCreditAccount(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    calcDebtAndCollateral(
      creditAccount: PromiseOrValue<string>,
      task: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimWithdrawals(
      creditAccount: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      action: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    closeCreditAccount(
      creditAccount: PromiseOrValue<string>,
      closureAction: PromiseOrValue<BigNumberish>,
      collateralDebtData: CollateralDebtDataStruct,
      payer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      skipTokensMask: PromiseOrValue<BigNumberish>,
      convertToETH: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    collateralTokenByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    collateralTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

    contractToAdapter(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    creditAccountInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    creditAccounts(overrides?: CallOverrides): Promise<BigNumber>;

    creditConfigurator(overrides?: CallOverrides): Promise<BigNumber>;

    creditFacade(overrides?: CallOverrides): Promise<BigNumber>;

    enabledTokensMaskOf(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    execute(
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fees(overrides?: CallOverrides): Promise<BigNumber>;

    flagsOf(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fullCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      enabledTokensMask: PromiseOrValue<BigNumberish>,
      collateralHints: PromiseOrValue<BigNumberish>[],
      minHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getActiveCreditAccountOrRevert(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBorrowerOrRevert(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTokenByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTokenMaskOrRevert(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isLiquidatable(
      creditAccount: PromiseOrValue<string>,
      minHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidationThresholds(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    manageDebt(
      creditAccount: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      enabledTokensMask: PromiseOrValue<BigNumberish>,
      action: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    maxEnabledTokens(overrides?: CallOverrides): Promise<BigNumber>;

    openCreditAccount(
      debt: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    pool(overrides?: CallOverrides): Promise<BigNumber>;

    poolQuotaKeeper(overrides?: CallOverrides): Promise<BigNumber>;

    poolService(overrides?: CallOverrides): Promise<BigNumber>;

    priceOracle(overrides?: CallOverrides): Promise<BigNumber>;

    quotedTokensMask(overrides?: CallOverrides): Promise<BigNumber>;

    revokeAdapterAllowances(
      creditAccount: PromiseOrValue<string>,
      revocations: RevocationPairStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    scheduleWithdrawal(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setActiveCreditAccount(
      creditAccount: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCollateralTokenData(
      token: PromiseOrValue<string>,
      ltInitial: PromiseOrValue<BigNumberish>,
      ltFinal: PromiseOrValue<BigNumberish>,
      timestampRampStart: PromiseOrValue<BigNumberish>,
      rampDuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setContractAllowance(
      adapter: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCreditConfigurator(
      _creditConfigurator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCreditFacade(
      _creditFacade: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFees(
      _feeInterest: PromiseOrValue<BigNumberish>,
      _feeLiquidation: PromiseOrValue<BigNumberish>,
      _liquidationDiscount: PromiseOrValue<BigNumberish>,
      _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFlagFor(
      creditAccount: PromiseOrValue<string>,
      flag: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxEnabledTokens(
      _maxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPriceOracle(
      _priceOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setQuotedMask(
      _quotedTokensMask: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supportsQuotas(overrides?: CallOverrides): Promise<BigNumber>;

    underlying(overrides?: CallOverrides): Promise<BigNumber>;

    updateQuota(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      quotaChange: PromiseOrValue<BigNumberish>,
      minQuota: PromiseOrValue<BigNumberish>,
      maxQuota: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    weth(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawalManager(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    accountFactory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    adapterToContract(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addCollateral(
      payer: PromiseOrValue<string>,
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addressProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approveCreditAccount(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    calcDebtAndCollateral(
      creditAccount: PromiseOrValue<string>,
      task: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimWithdrawals(
      creditAccount: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      action: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    closeCreditAccount(
      creditAccount: PromiseOrValue<string>,
      closureAction: PromiseOrValue<BigNumberish>,
      collateralDebtData: CollateralDebtDataStruct,
      payer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      skipTokensMask: PromiseOrValue<BigNumberish>,
      convertToETH: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    collateralTokenByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collateralTokensCount(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    contractToAdapter(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    creditAccountInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    creditAccounts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    creditConfigurator(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    creditFacade(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    enabledTokensMaskOf(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    execute(
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fees(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    flagsOf(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fullCollateralCheck(
      creditAccount: PromiseOrValue<string>,
      enabledTokensMask: PromiseOrValue<BigNumberish>,
      collateralHints: PromiseOrValue<BigNumberish>[],
      minHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getActiveCreditAccountOrRevert(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBorrowerOrRevert(
      creditAccount: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTokenByMask(
      tokenMask: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTokenMaskOrRevert(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isLiquidatable(
      creditAccount: PromiseOrValue<string>,
      minHealthFactor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidationThresholds(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    manageDebt(
      creditAccount: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      enabledTokensMask: PromiseOrValue<BigNumberish>,
      action: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    maxEnabledTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    openCreditAccount(
      debt: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    pool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolQuotaKeeper(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolService(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceOracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    quotedTokensMask(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    revokeAdapterAllowances(
      creditAccount: PromiseOrValue<string>,
      revocations: RevocationPairStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    scheduleWithdrawal(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setActiveCreditAccount(
      creditAccount: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCollateralTokenData(
      token: PromiseOrValue<string>,
      ltInitial: PromiseOrValue<BigNumberish>,
      ltFinal: PromiseOrValue<BigNumberish>,
      timestampRampStart: PromiseOrValue<BigNumberish>,
      rampDuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setContractAllowance(
      adapter: PromiseOrValue<string>,
      targetContract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCreditConfigurator(
      _creditConfigurator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCreditFacade(
      _creditFacade: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFees(
      _feeInterest: PromiseOrValue<BigNumberish>,
      _feeLiquidation: PromiseOrValue<BigNumberish>,
      _liquidationDiscount: PromiseOrValue<BigNumberish>,
      _feeLiquidationExpired: PromiseOrValue<BigNumberish>,
      _liquidationDiscountExpired: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFlagFor(
      creditAccount: PromiseOrValue<string>,
      flag: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxEnabledTokens(
      _maxEnabledTokens: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPriceOracle(
      _priceOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setQuotedMask(
      _quotedTokensMask: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supportsQuotas(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    underlying(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateQuota(
      creditAccount: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      quotaChange: PromiseOrValue<BigNumberish>,
      minQuota: PromiseOrValue<BigNumberish>,
      maxQuota: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    weth(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawalManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
